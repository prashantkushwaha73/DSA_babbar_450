*********************************************************************************************************************************
**** 1 -  Min Number of Flips ( 02/11/23 ) ****

int solve0(string S){
    bool flag = false;
    int r = 0;
    for(int i=0;i<S.size();i++){
        if(flag){
            if(S[i]=='0'){
                r++;
            }
            flag = false;
        }
        else{
            if(S[i] == '1'){
                r++;
            }
            flag = true;
        }
    }
    return r;
}

int solve1(string S){
    bool flag = true;
    int r = 0;
    for(int i=0;i<S.size();i++){
        if(flag){
            if(S[i]=='0'){
                r++;
            }
            flag = false;
        }
        else{
            if(S[i] == '1'){
                r++;
            }
            flag = true;
        }
    }
    return r;
}


int minFlips (string S)
{
    return min(solve0(S),solve1(S));
}

************************************************************************************************************
**** 2 - Reverse a linked list ( 05/11/23 ) ****

class Solution
{
    public:
    //Function to reverse a linked list.
    struct Node* reverseList(struct Node *head)
    {
        Node* first = head;
        Node* second = head->next;
        first->next = NULL;
        Node* posi;
        while(second){
           posi = second -> next;
           second -> next = first;
           first = second;
           second = posi;
        }
        return first;
    }
    
};

*******************************************************************************************************
**** 3 - 311 - Overlapping Intervals ( 05/11/23 ) ****

class Solution {
public:
    vector<vector<int>> overlappedInterval(vector<vector<int>>& intervals) {
         priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> pq;
         for(int i=0;i<intervals.size();i++){
             pq.push(intervals[i]);
         }
         vector<vector<int>> ans;
         vector<int> v;
         ans.push_back(pq.top());
         pq.pop();
         while(!pq.empty()){
             v = pq.top();
             pq.pop();
             if(v[0] <= ans[ans.size()-1][1]){
                 if(v[1] > ans[ans.size()-1][1]){
                     ans[ans.size()-1][1] = v[1];
                 }
             }
             else{
                 ans.push_back(v);
             }
         }
        return ans;
    }
};

***************************************************************************************************
**** 4 - 32 - Array Subset of another array ( 06/11/23 ) ****

string isSubset(int a1[], int a2[], int n, int m) {
    if(n<m){
        return "No";
    }
    unordered_map<int,int> map;
    for(int i=0;i<n;i++){
        map[a1[i]]++;
    }
    for(int i=0;i<m;i++){
        if(map[a2[i]]>0){
            map[a2[i]]--;
        }
        else{
            return "No";
        }
    }
    return "Yes";
}

***************************************************************************************************************
**** 5 - 169 - Merge K sorted linked lists ( 09/11/23 ) ****

class Solution{
  public:
    //Function to merge K sorted linked list.
    class Compare {
public:
    bool operator()(Node* below, Node* above)
    {
        if (below->data > above->data) {
            return true;
        }
        return false;
    }
};

    Node * mergeKLists(Node *arr[], int K)
    {
           priority_queue<Node*,vector<Node*>,Compare> pq;
           for(int i=0;i<K;i++){
               pq.push(arr[i]);
           }
           Node* temp = pq.top();
           pq.pop();
           Node* ans = temp;
           Node* pemp = ans;
           if(temp->next){
               pq.push(temp->next);
           }
           while(!pq.empty()){
               temp = pq.top();
               pq.pop();
               pemp->next = temp;
               pemp = temp;
               if(temp->next){
                   pq.push(temp->next);
               }
           }
           pemp->next = NULL;
           return ans;
    }
};

***************************************************************************************************
**** 6 - 150 -  Intersection Point in Y Shaped Linked Lists ( 25/11/23 ) ****

int intersectPoint(Node* head1, Node* head2)
{
    int size1 = 0 , size2 = 0;
    Node* temp = head1;
    while(temp){
        size1++;
        temp = temp->next;
    }
    temp = head2;
    while(temp){
        size2++;
        temp = temp->next;
    }
    if(size1 > size2){
        for(int i=0;i<(size1-size2);i++){
            head1 = head1->next;
        }
    }
    else{
        for(int i=0;i<(size2-size1);i++){
            head2 = head2->next;
        }
    }
    while(head1 && head2){
        if(head1==head2){
            return head1->data;
        }
        head1 = head1->next;
        head2 = head2->next;
    }
    return -1;
}

****************************************************************************************************
