*************************************************************
**** 141 - Detect Loop in linked list ( 07/07/23 ) ****

class Solution
{
    public:
    //Function to check if the linked list has a loop.
    bool detectLoop(Node* head)
    {
        Node* temp=head;
        Node* pemp=head->next;
        while(pemp){
            if(temp==pemp){
                return true;
            }
            temp = temp->next;
            pemp = pemp->next;
            if(pemp){
                pemp = pemp->next;
            }
        }
        return false;
    }
};

***********************************************************************************
**** 182 - Inorder Traversal ( 07/07/23 ) ****

class Solution {
  public:
  
    void solve(vector<int>& v,Node* root){
        if(root==NULL){
            return;
        }
        solve(v,root->left);
        v.push_back(root->data);
        solve(v,root->right);
        
    }
    // Function to return a list containing the inorder traversal of the tree.
    vector<int> inOrder(Node* root) {
        vector<int> v;
        solve(v,root);
        return v;
    }
};

**************************************************************************************
**** Minimum element in BST ( 08/07/23 ) ****

int minValue(Node* root) {
    if(root==NULL){
        return -1;
    }
    while(root->left){
        root = root->left;
    }
    return root->data;
}

**********************************************************************
**** 108 -  Majority Element ( 09/07/23 ) **** 

class Solution{
  public:
     // Function to find majority element in the array
    // a: input array
    // size: size of input array
    int majorityElement(int a[], int size)
    {
        sort(a,a+size);
        int count = 0 , value=-1;
        for(int i=0;i<size;i++){
            if(a[i]!=value){
                if(count>(size/2)){
                    return value;
                }
                count=1;
                value=a[i];
            }
            else{
                count++;
            }
        }
        if(count>(size/2)){
                    return value;
                }
        return -1;
    }
};

****************************************************************************************
**** 72 - Word Break ( 18/07/23 ) **** 

class Solution
{
public:
    void solve(unordered_map<string,bool>& m,string s,bool& ans){
        if(s.size()==0){
            ans = true; 
            return;
        }
        for(int i=1;i<=s.size();i++){
            if(m[s.substr(0,i)]){
                solve(m,s.substr(i,s.size()-i),ans);
            }
        }
        
    }
    int wordBreak(string A, vector<string> &B) {
        unordered_map<string,bool> m;
        for(int i=0;i<B.size();i++){
            m[B[i]]=true;
        }
        bool ans = false;
        solve(m,A,ans);
        return ans;
    }
};

*************************************************************************************************
**** 81 - Roman Number to Integer ( 18/07/23 ) ****

class Solution {
  public:
    int romanToDecimal(string &str) {
        unordered_map<char,pair<int,int>> m;
        m['I']={1,1}; m['V']={5,2} ; m['X']= {10,3} ; m['L']={50,4}; m['C']={100,5}; m['D']={500,6}; m['M']={1000,7};
        reverse(str.begin(),str.end());
        int ans = 0;
        for(int i=0;i<str.size();i++){
            if(i<str.size()-1 && m[str[i]].second > m[str[i+1]].second){
                ans += (m[str[i]].first - m[str[i+1]].first);
                i++;
            }
            else{
            ans += m[str[i]].first;
            }
        }
        return ans;
    }
};

****************************************************************************************************
**** 247 - Shop in Candy Store ( 20/07/23 ) ****

class Solution
{
public:
    vector<int> candyStore(int candies[], int N, int K)
    {
        vector<int> v;
        for(int i=0;i<N;i++){
            v.push_back(candies[i]);
        }
        sort(v.begin(),v.end());
        int a = 0, b = v.size()-1,mini=0,maxi=0;
        while(b>=a){
            mini += v[a];
            a++;
            b = b - K;
        }
        a = v.size()-1; b = 0;
        while(a>=b){
            maxi += v[a];
            a--;
            b = b + K;
        }
        return {mini,maxi};
    }
};

***********************************************************************************************************
**** 128 - Arithmetic Number ( 26/07/23 ) ****

class Solution{
public:
    int inSequence(int A, int B, int C){
        if(C==0){
            if(A==B){
                return true;
            }
            else{
                return false;
            }
        }
        
        if((((B-A)/C)+1) < 1 ){
            return false;
        }
        else if((B-A)%C){
            return false;
        }
        else{
            return true;;
        }
    }
};

**************************************************************************************************************
**** 16 - 287. Find the Duplicate Number ( 26/07/23 ) ****

class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        vector<bool> v(nums.size(),false);
        for(int i=0;i<nums.size();i++){
            if(v[nums[i]]){
                return nums[i];
            }
            else{
                v[nums[i]] = true;
            }
        }
        return true;
    }
};

*********************************************************************************************************
**** Intersection Point in Y Shaped Linked Lists ( 27/07/23 ) ****

int intersectPoint(Node* head1, Node* head2)
{
    int size1 = 0 , size2 = 0;
    Node* temp = head1;
    while(temp){
        size1++;
        temp = temp->next;
    }
    temp = head2;
    while(temp){
        size2++;
        temp = temp->next;
    }
    if(size1 > size2){
        for(int i=0;i<(size1-size2);i++){
            head1 = head1->next;
        }
    }
    else{
        for(int i=0;i<(size2-size1);i++){
            head2 = head2->next;
        }
    }
    while(head1 && head2){
        if(head1==head2){
            return head1->data;
        }
        head1 = head1->next;
        head2 = head2->next;
    }
    return -1;
}


***************************************************************************************************
