*************************************************************
**** 141 - Detect Loop in linked list ( 07/07/23 ) ****

class Solution
{
    public:
    //Function to check if the linked list has a loop.
    bool detectLoop(Node* head)
    {
        Node* temp=head;
        Node* pemp=head->next;
        while(pemp){
            if(temp==pemp){
                return true;
            }
            temp = temp->next;
            pemp = pemp->next;
            if(pemp){
                pemp = pemp->next;
            }
        }
        return false;
    }
};

***********************************************************************************
**** 182 - Inorder Traversal ( 07/07/23 ) ****

class Solution {
  public:
  
    void solve(vector<int>& v,Node* root){
        if(root==NULL){
            return;
        }
        solve(v,root->left);
        v.push_back(root->data);
        solve(v,root->right);
        
    }
    // Function to return a list containing the inorder traversal of the tree.
    vector<int> inOrder(Node* root) {
        vector<int> v;
        solve(v,root);
        return v;
    }
};

**************************************************************************************
**** Minimum element in BST ( 08/07/23 ) ****

int minValue(Node* root) {
    if(root==NULL){
        return -1;
    }
    while(root->left){
        root = root->left;
    }
    return root->data;
}

**********************************************************************
**** 108 -  Majority Element ( 09/07/23 ) **** 

class Solution{
  public:
     // Function to find majority element in the array
    // a: input array
    // size: size of input array
    int majorityElement(int a[], int size)
    {
        sort(a,a+size);
        int count = 0 , value=-1;
        for(int i=0;i<size;i++){
            if(a[i]!=value){
                if(count>(size/2)){
                    return value;
                }
                count=1;
                value=a[i];
            }
            else{
                count++;
            }
        }
        if(count>(size/2)){
                    return value;
                }
        return -1;
    }
};

****************************************************************************************
**** 72 - Word Break ( 18/07/23 ) **** 

class Solution
{
public:
    void solve(unordered_map<string,bool>& m,string s,bool& ans){
        if(s.size()==0){
            ans = true; 
            return;
        }
        for(int i=1;i<=s.size();i++){
            if(m[s.substr(0,i)]){
                solve(m,s.substr(i,s.size()-i),ans);
            }
        }
        
    }
    int wordBreak(string A, vector<string> &B) {
        unordered_map<string,bool> m;
        for(int i=0;i<B.size();i++){
            m[B[i]]=true;
        }
        bool ans = false;
        solve(m,A,ans);
        return ans;
    }
};

*************************************************************************************************
**** 81 - Roman Number to Integer ( 18/07/23 ) ****

class Solution {
  public:
    int romanToDecimal(string &str) {
        unordered_map<char,pair<int,int>> m;
        m['I']={1,1}; m['V']={5,2} ; m['X']= {10,3} ; m['L']={50,4}; m['C']={100,5}; m['D']={500,6}; m['M']={1000,7};
        reverse(str.begin(),str.end());
        int ans = 0;
        for(int i=0;i<str.size();i++){
            if(i<str.size()-1 && m[str[i]].second > m[str[i+1]].second){
                ans += (m[str[i]].first - m[str[i+1]].first);
                i++;
            }
            else{
            ans += m[str[i]].first;
            }
        }
        return ans;
    }
};

****************************************************************************************************
**** 247 - Shop in Candy Store ( 20/07/23 ) ****

class Solution
{
public:
    vector<int> candyStore(int candies[], int N, int K)
    {
        vector<int> v;
        for(int i=0;i<N;i++){
            v.push_back(candies[i]);
        }
        sort(v.begin(),v.end());
        int a = 0, b = v.size()-1,mini=0,maxi=0;
        while(b>=a){
            mini += v[a];
            a++;
            b = b - K;
        }
        a = v.size()-1; b = 0;
        while(a>=b){
            maxi += v[a];
            a--;
            b = b + K;
        }
        return {mini,maxi};
    }
};

***********************************************************************************************************
**** 128 - Arithmetic Number ( 26/07/23 ) ****

class Solution{
public:
    int inSequence(int A, int B, int C){
        if(C==0){
            if(A==B){
                return true;
            }
            else{
                return false;
            }
        }
        
        if((((B-A)/C)+1) < 1 ){
            return false;
        }
        else if((B-A)%C){
            return false;
        }
        else{
            return true;;
        }
    }
};

**************************************************************************************************************
**** 16 - 287. Find the Duplicate Number ( 26/07/23 ) ****

class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        vector<bool> v(nums.size(),false);
        for(int i=0;i<nums.size();i++){
            if(v[nums[i]]){
                return nums[i];
            }
            else{
                v[nums[i]] = true;
            }
        }
        return true;
    }
};

*********************************************************************************************************
**** Intersection Point in Y Shaped Linked Lists ( 27/07/23 ) ****

int intersectPoint(Node* head1, Node* head2)
{
    int size1 = 0 , size2 = 0;
    Node* temp = head1;
    while(temp){
        size1++;
        temp = temp->next;
    }
    temp = head2;
    while(temp){
        size2++;
        temp = temp->next;
    }
    if(size1 > size2){
        for(int i=0;i<(size1-size2);i++){
            head1 = head1->next;
        }
    }
    else{
        for(int i=0;i<(size2-size1);i++){
            head2 = head2->next;
        }
    }
    while(head1 && head2){
        if(head1==head2){
            return head1->data;
        }
        head1 = head1->next;
        head2 = head2->next;
    }
    return -1;
}


***************************************************************************************************
**** 194 - Binary Tree to DLL ( 31/07/23 ) ****

class Solution
{
    public: 
    //Function to convert binary tree to doubly linked list and return it.
    void solve(Node* root,bool& flag,Node* &ans,Node* &prev,Node* &pres){
        if(root==NULL){
            return;
        }
        solve(root->left,flag,ans,prev,pres);
        if(flag){
            Node* temp = new Node(root->data);
            temp -> left = prev;
            prev = temp;
            pres -> right = temp;
            pres = temp;
        }
        else{
            Node* temp = new Node(root->data);
            flag = true;
            temp -> left = prev;
            prev = temp;
            ans = temp;
            pres = temp;
        }
        solve(root->right,flag,ans,prev,pres);
    }
    
    Node * bToDLL(Node *root)
    {
        bool flag =  false;
        Node* ans = NULL;
        Node* prev = NULL;
        Node* pres;
        solve(root,flag,ans,prev,pres);
        return ans;
    }
};


**************************************************************************************************
**** 171 - Delete nodes having greater value on right ( 01/08/23 ) ****

class Solution
{
    public:
    Node *compute(Node *head)
    {
        vector<int> v;
        Node* temp = head;
        while(temp){
            v.push_back(temp->data);
            temp = temp->next;
        }
        stack<int> st;
        for(int i=0;i<v.size();i++){
            if(st.empty()){
                st.push(v[i]);
            }
            else{
                while(!st.empty() && st.top()<v[i]){
                    st.pop();
                }
                st.push(v[i]);
            }
        }
        v.clear();
        while(!st.empty()){
            v.push_back(st.top());
            st.pop();
        }
        reverse(v.begin(),v.end());
        head = new Node(v[0]);
        temp = head;
        for(int i=1;i<v.size();i++){
            Node* node = new Node(v[i]);
            temp->next = node;
            temp = node;
        }
        return head;
    }
    
};

*********************************************************************************************
**** 385 - Longest Path in a Directed Acyclic Graph ( 01/08/23 ) ****

class Solution
{
    public:
    
    void dfs(unordered_map<int,vector<pair<int,int>>>& m,vector<int>& ans,int n){
        for(int i=0;i<m[n].size();i++){
                if(ans[n]+m[n][i].second > ans[m[n][i].first]){
                    ans[m[n][i].first] = ans[n]+m[n][i].second;
                    dfs(m,ans,m[n][i].first);
                }
            }
    }
    
      vector <int> maximumDistance(vector<vector<int>> edges,int v,int e,int src)
      {
            unordered_map<int,vector<pair<int,int>>> m;
            for(int i=0;i<e;i++){
                m[edges[i][0]].push_back({edges[i][1],edges[i][2]});
            }
            vector<int> ans(v,INT_MIN);
            ans[src] = 0;
            for(int i=0;i<m[src].size();i++){
                if(ans[src]+m[src][i].second > ans[m[src][i].first]){
                    ans[m[src][i].first] = ans[src]+m[src][i].second;
                    dfs(m,ans,m[src][i].first);
                }
            }
            return ans;
      }
};

*******************************************************************************************************
**** Min distance between two given nodes of a Binary Tree ( 03/08/23 ) ****

class Solution{
    public:
     Node* lca(Node* root ,int n1 ,int n2 )
    {
       if(root==NULL){
           return NULL;
       }
       if(root->data==n1 || root->data==n2){
           return root;
       }
       Node* left=lca(root->left,n1,n2);
       Node* right=lca(root->right,n1,n2);
       if(left!=NULL && right!=NULL){
           return root;
       }
       else if(left==NULL && right!=NULL){
           return right;
       }
       else if(right==NULL && left!=NULL){
           return left;
       }
       else{
           return NULL;
       }
    }
    
    void solve(Node* root,int n,int count,int& ans){
        if(root == NULL){
            return;
        }
        if(root->data == n){
            ans = count;
            return;
        }
        solve(root->left,n,count+1,ans);
        solve(root->right,n,count+1,ans);
    }
    
    /* Should return minimum distance between a and b
    in a tree with given root*/
    int findDist(Node* root, int a, int b) {
        root  = lca(root,a,b);
        if(root->data == a){
            int ans ;
            solve(root,b,0,ans);
            return ans;
        }
        else if(root->data == b){
            int ans;
            solve(root,a,0,ans);
            return ans;
        }
        else{
            int ans1;
            solve(root,a,0,ans1);
            int ans2;
            solve(root,b,0,ans2);
            return ans1+ans2;
        }
        
    }
};

****************************************************************************************************
**** Next Greater Element ( 03/08/23 ) ****

class Solution
{
    public:
    //Function to find the next greater element for each element of the array.
    vector<long long> nextLargerElement(vector<long long> arr, int n){
     stack<long long> st;
     vector<long long> ans(n,0);
     for(int i=arr.size()-1;i>=0;i--){
         while(!st.empty() && st.top() <= arr[i]){
             st.pop();
         }
         if(!st.empty()){
             ans[i] = st.top();
         }
         else{
             ans[i] = -1;
         }
         st.push(arr[i]);
     }
     return ans;
    }
};

***********************************************************************************************
**** Find Missing And Repeating ( 04/08/23 ) ****

class Solution{
public:
    vector<int> findTwoElement(vector<int> arr, int n) {
        vector<bool> v(n+1,false);
        vector<int> ans;
        for(int i=0;i<arr.size();i++){
            if(v[arr[i]]){
                ans.push_back(arr[i]);
            }
            else{
                v[arr[i]] = true;
            }
        }
        for(int i=1;i<n+1;i++){
            if(v[i] == false){
                ans.push_back(i);
            }
        }
        return ans;
    }
};

*******************************************************************************************
**** Populate Inorder Successor for all nodes ( 04/08/23 ) ****

class Solution
{
public:

   void solve(Node* root,vector<Node*>& v){
       if(root==NULL){
           return;
       }
       solve(root->left,v);
       v.push_back(root);
       solve(root->right,v);
   }

    void populateNext(Node *root)
    {
       vector<Node*> v;
       solve(root,v);
      for(int i=0;i<v.size()-1;i++){
          v[i]->next = v[i+1];
      }
    }
};

*******************************************************************************************
**** 18 - 88. Merge Sorted Array ( 07/08/23 ) ****

class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i=0,j=0,index=0;
        vector<int> ans(m+n);
    while(i<m && j<n){
        if(nums1[i] < nums2[j]){
            ans[index++]=nums1[i++];
        }
        else if(nums2[j]<nums1[i]){
            ans[index++]=nums2[j++];
        }
        else{
            ans[index++]=nums1[i++];
            ans[index++]=nums2[j++];
        } }
   
    while(i<m){
        ans[index++]=nums1[i++];
    }
    while(j<n){
        ans[index++]=nums2[j++];
            }
   nums1=ans;
    }
};

******************************************************************************************************
**** 19 - Implement two stacks in an array ( 09/08/23 ) ****

class twoStacks
{
    vector<int> v1;
    vector<int> v2;
    int n;
    public:
    
 
    //Function to push an integer into the stack1.
    void push1(int x)
    {
     v1.push_back(x);   
    }
    
    //Function to push an integer into the stack2.
    void push2(int x)
    {
       v2.push_back(x);
    }
    
    //Function to remove an element from top of the stack1.
    int pop1()
    {
        if(v1.size()==0){
            return -1;
        }
        else{
            n = v1[v1.size()-1];
            v1.pop_back();
            return n;
        }
    }
    
    //Function to remove an element from top of the stack2.
    int pop2()
    {
       if(v2.size()==0){
           return -1;
       }
       else{
           n = v2[v2.size()-1];
           v2.pop_back();
           return n;
       }
    }
};

**********************************************************************************************************
