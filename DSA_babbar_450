*************************************************************
**** 141 - Detect Loop in linked list ( 07/07/23 ) ****

class Solution
{
    public:
    //Function to check if the linked list has a loop.
    bool detectLoop(Node* head)
    {
        Node* temp=head;
        Node* pemp=head->next;
        while(pemp){
            if(temp==pemp){
                return true;
            }
            temp = temp->next;
            pemp = pemp->next;
            if(pemp){
                pemp = pemp->next;
            }
        }
        return false;
    }
};

***********************************************************************************
**** 182 - Inorder Traversal ( 07/07/23 ) ****

class Solution {
  public:
  
    void solve(vector<int>& v,Node* root){
        if(root==NULL){
            return;
        }
        solve(v,root->left);
        v.push_back(root->data);
        solve(v,root->right);
        
    }
    // Function to return a list containing the inorder traversal of the tree.
    vector<int> inOrder(Node* root) {
        vector<int> v;
        solve(v,root);
        return v;
    }
};

**************************************************************************************
**** Minimum element in BST ( 08/07/23 ) ****

int minValue(Node* root) {
    if(root==NULL){
        return -1;
    }
    while(root->left){
        root = root->left;
    }
    return root->data;
}

**********************************************************************
**** 108 -  Majority Element ( 09/07/23 ) **** 

class Solution{
  public:
     // Function to find majority element in the array
    // a: input array
    // size: size of input array
    int majorityElement(int a[], int size)
    {
        sort(a,a+size);
        int count = 0 , value=-1;
        for(int i=0;i<size;i++){
            if(a[i]!=value){
                if(count>(size/2)){
                    return value;
                }
                count=1;
                value=a[i];
            }
            else{
                count++;
            }
        }
        if(count>(size/2)){
                    return value;
                }
        return -1;
    }
};

****************************************************************************************
**** 72 - Word Break ( 18/07/23 ) **** 

class Solution
{
public:
    void solve(unordered_map<string,bool>& m,string s,bool& ans){
        if(s.size()==0){
            ans = true; 
            return;
        }
        for(int i=1;i<=s.size();i++){
            if(m[s.substr(0,i)]){
                solve(m,s.substr(i,s.size()-i),ans);
            }
        }
        
    }
    int wordBreak(string A, vector<string> &B) {
        unordered_map<string,bool> m;
        for(int i=0;i<B.size();i++){
            m[B[i]]=true;
        }
        bool ans = false;
        solve(m,A,ans);
        return ans;
    }
};

*************************************************************************************************
**** 81 - Roman Number to Integer ( 18/07/23 ) ****

class Solution {
  public:
    int romanToDecimal(string &str) {
        unordered_map<char,pair<int,int>> m;
        m['I']={1,1}; m['V']={5,2} ; m['X']= {10,3} ; m['L']={50,4}; m['C']={100,5}; m['D']={500,6}; m['M']={1000,7};
        reverse(str.begin(),str.end());
        int ans = 0;
        for(int i=0;i<str.size();i++){
            if(i<str.size()-1 && m[str[i]].second > m[str[i+1]].second){
                ans += (m[str[i]].first - m[str[i+1]].first);
                i++;
            }
            else{
            ans += m[str[i]].first;
            }
        }
        return ans;
    }
};

****************************************************************************************************
