******************************************************************************************
**** 1 - 145 -  Remove duplicates from an unsorted linked list ( 01/10/23 ) ****

/*
The structure of linked list is the following

struct Node {
  int data;
  struct Node *next;
  Node(int x) {
    data = x;
    next = NULL;
  }
};
*/


class Solution
{
    public:
    //Function to remove duplicates from unsorted linked list.
    Node * removeDuplicates( Node *head) 
    {
     unordered_map<int,bool> m;
     Node* first = head;
     m[head->data]=true;
     if(head->next){
         Node* second = head->next;
         while(second){
             if(m[second->data]){
                 first->next = second->next;
                 second = second -> next;
             }
             else{
                 m[second->data]=true;
                 first = second ;
                 second = second -> next;
             }
         }
         return head;
     }
     else{
         return first;
     }
     return NULL;
    }
};


********************************************************************************************************************
**** 2 - 33 - Triplet Sum in Array ( 02/10/23 ) ****

class Solution{
    public:
    //Function to find if there exists a triplet in the 
    //array A[] which sums up to X.
    bool find3Numbers(int arr[], int n, int x)
    {
         sort(arr,arr+n);
         int i = 0,j,k;
         for(int i=0;i<n-2;i++){
             j = i+1; k = n-1;
             while(j<k){
                 if(arr[i]+arr[j]+arr[k] == x){
                     return true;
                 }
                 else if(arr[i]+arr[j]+arr[k] > x){
                     k--;
                 }
                 else{
                     j++;
                 }
             }
         }
         return false;
    }
};

****************************************************************************
**** 3 - 93 - Remove Consecutive Characters ( 03/10/23 ) ****

class Solution{
    public:
    string removeConsecutiveCharacter(string s)
    {
        stack<char> st;
        st.push(s[0]);
        for(int i=1;i<s.size();i++){
            if(st.top()!=s[i]){
                st.push(s[i]);
            }
        }
        string ans;
        while(!st.empty()){
            ans.push_back(st.top());
            st.pop();
        }
        reverse(ans.begin(),ans.end());
        return ans;
    }
};

********************************************************************************
**** 4 - 223 - Normal BST to Balanced BST ( 04/10/23 ) ****

class Solution{
    public:
    void solve1(Node* root,vector<int> &v){
        if(root==NULL){
            return;
        }
        solve1(root->left,v);
        v.push_back(root->data);
        solve1(root->right,v);
    }
    
    Node* solve2(vector<int> v,int s,int e){
        int mid = s+(e-s)/2;
        Node* temp = new Node(v[mid]);
        if(s<=mid-1){
        temp->left = solve2(v,s,mid-1);}
        if(mid+1<=e){
        temp->right = solve2(v,mid+1,e);}
        return temp;
    }
    
    Node* buildBalancedTree(Node* root)
    {
    	vector<int> v;
    	solve1(root,v);
    	return solve2(v,0,v.size()-1);
    }
};

********************************************************************************************
